/* tslint:disable */
/* eslint-disable */
/**
 * job-support-api-beta
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2022-02-07T01:46:56Z
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 * 通知
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   *
   * @type {number}
   * @memberof Activity
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof Activity
   */
  user_id: number
  /**
   *
   * @type {number}
   * @memberof Activity
   */
  action_type_id: number
  /**
   *
   * @type {boolean}
   * @memberof Activity
   */
  is_read?: boolean
  /**
   *
   * @type {number}
   * @memberof Activity
   */
  model_id?: number
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  content?: string
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  updated_at: string
}
/**
 * 認証時のデータ
 * @export
 * @interface Admin
 */
export interface Admin {
  /**
   * ユーザーID
   * @type {number}
   * @memberof Admin
   */
  id: number
  /**
   * フルネーム
   * @type {string}
   * @memberof Admin
   */
  full_name: string
  /**
   * 名
   * @type {string}
   * @memberof Admin
   */
  given_name?: string
  /**
   * 姓
   * @type {string}
   * @memberof Admin
   */
  family_name?: string
  /**
   * ファイルパス
   * @type {string}
   * @memberof Admin
   */
  file_path?: string | null
  /**
   *
   * @type {string}
   * @memberof Admin
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Admin
   */
  updated_at: string
}
/**
 * 認証時のデータ
 * @export
 * @interface AuthenticatedAdmin
 */
export interface AuthenticatedAdmin {
  /**
   * ユーザーID
   * @type {number}
   * @memberof AuthenticatedAdmin
   */
  id: number
  /**
   * フルネーム
   * @type {string}
   * @memberof AuthenticatedAdmin
   */
  full_name: string
  /**
   * 名
   * @type {string}
   * @memberof AuthenticatedAdmin
   */
  given_name?: string
  /**
   * 姓
   * @type {string}
   * @memberof AuthenticatedAdmin
   */
  family_name?: string
  /**
   * ファイルパス
   * @type {string}
   * @memberof AuthenticatedAdmin
   */
  file_path?: string | null
  /**
   *
   * @type {string}
   * @memberof AuthenticatedAdmin
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof AuthenticatedAdmin
   */
  updated_at: string
  /**
   *
   * @type {string}
   * @memberof AuthenticatedAdmin
   */
  jwt?: string
}
/**
 * ブログ
 * @export
 * @interface Blog
 */
export interface Blog {
  /**
   *
   * @type {number}
   * @memberof Blog
   */
  id: number
  /**
   *
   * @type {User}
   * @memberof Blog
   */
  written_by: User
  /**
   * タイトル
   * @type {string}
   * @memberof Blog
   */
  title: string
  /**
   * 記事の内容
   * @type {string}
   * @memberof Blog
   */
  body: string
  /**
   *
   * @type {string}
   * @memberof Blog
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Blog
   */
  updated_at: string
  /**
   *
   * @type {Array<BlogImage>}
   * @memberof Blog
   */
  images?: Array<BlogImage>
  /**
   *
   * @type {Array<User>}
   * @memberof Blog
   */
  likes: Array<User>
  /**
   *
   * @type {Array<BlogComment>}
   * @memberof Blog
   */
  comments: Array<BlogComment>
  /**
   *
   * @type {Array<Tag>}
   * @memberof Blog
   */
  tags: Array<Tag>
}
/**
 * ブログへのコメント
 * @export
 * @interface BlogComment
 */
export interface BlogComment {
  /**
   *
   * @type {number}
   * @memberof BlogComment
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof BlogComment
   */
  blog_id: number
  /**
   *
   * @type {User}
   * @memberof BlogComment
   */
  written_by: User
  /**
   *
   * @type {string}
   * @memberof BlogComment
   */
  body: string
  /**
   *
   * @type {string}
   * @memberof BlogComment
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof BlogComment
   */
  updated_at: string
}
/**
 * Blogのコメントフォーム
 * @export
 * @interface BlogCommentForm
 */
export interface BlogCommentForm {
  /**
   *
   * @type {number}
   * @memberof BlogCommentForm
   */
  written_by: number
  /**
   *
   * @type {string}
   * @memberof BlogCommentForm
   */
  body: string
}
/**
 * Blogの投稿フォーム
 * @export
 * @interface BlogForm
 */
export interface BlogForm {
  /**
   *
   * @type {string}
   * @memberof BlogForm
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof BlogForm
   */
  body: string
  /**
   *
   * @type {number}
   * @memberof BlogForm
   */
  written_by?: number
  /**
   *
   * @type {Array<object>}
   * @memberof BlogForm
   */
  images?: Array<object>
  /**
   * 初投稿時はなくても良い
   * @type {Array<string>}
   * @memberof BlogForm
   */
  file_paths?: Array<string>
  /**
   *
   * @type {Array<number>}
   * @memberof BlogForm
   */
  tags?: Array<number>
}
/**
 * ブログ画像
 * @export
 * @interface BlogImage
 */
export interface BlogImage {
  /**
   *
   * @type {number}
   * @memberof BlogImage
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof BlogImage
   */
  blog_id: number
  /**
   *
   * @type {string}
   * @memberof BlogImage
   */
  file_path: string
  /**
   *
   * @type {string}
   * @memberof BlogImage
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof BlogImage
   */
  updated_at: string
}
/**
 * ブログ一覧のページ（ページャつき）
 * @export
 * @interface BlogPage
 */
export interface BlogPage {
  /**
   *
   * @type {Array<Blog>}
   * @memberof BlogPage
   */
  data: Array<Blog>
  /**
   * 1ページ目のURL
   * @type {string}
   * @memberof BlogPage
   */
  first_page_url: string
  /**
   * 現在のitemの開始位置
   * @type {number}
   * @memberof BlogPage
   */
  from: number | null
  /**
   * 最大ページ数
   * @type {number}
   * @memberof BlogPage
   */
  last_page: number
  /**
   * 最終ページのURL
   * @type {string}
   * @memberof BlogPage
   */
  last_page_url: string
  /**
   * 次ページのURL
   * @type {string}
   * @memberof BlogPage
   */
  next_page_url: string | null
  /**
   * 前ページのURL
   * @type {string}
   * @memberof BlogPage
   */
  path: string
  /**
   * 1ページあたりのアイテム数
   * @type {number}
   * @memberof BlogPage
   */
  per_page: number
  /**
   * 前ページのURL
   * @type {string}
   * @memberof BlogPage
   */
  prev_page_url: string | null
  /**
   * 現在のitemの終了位置
   * @type {number}
   * @memberof BlogPage
   */
  to: number | null
  /**
   * item総数
   * @type {number}
   * @memberof BlogPage
   */
  total: number
}
/**
 * ユーザが任意でパスワードを変更したい時
 * @export
 * @interface ChangePasswordInput
 */
export interface ChangePasswordInput {
  /**
   *
   * @type {string}
   * @memberof ChangePasswordInput
   */
  old_password: string
  /**
   *
   * @type {string}
   * @memberof ChangePasswordInput
   */
  password: string
  /**
   *
   * @type {string}
   * @memberof ChangePasswordInput
   */
  password_confirmation: string
}
/**
 * チャットメッセージ
 * @export
 * @interface ChatMessage
 */
export interface ChatMessage {
  /**
   *
   * @type {number}
   * @memberof ChatMessage
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  body: string
  /**
   *
   * @type {User}
   * @memberof ChatMessage
   */
  written_by: User
  /**
   *
   * @type {User}
   * @memberof ChatMessage
   */
  to?: User
  /**
   *
   * @type {Array<ChatMessageImage>}
   * @memberof ChatMessage
   */
  images?: Array<ChatMessageImage>
  /**
   *
   * @type {Array<Reaction>}
   * @memberof ChatMessage
   */
  reactions?: Array<Reaction>
  /**
   *
   * @type {Array<User>}
   * @memberof ChatMessage
   */
  chat_message_reads?: Array<User>
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  updated_at: string
  /**
   *
   * @type {boolean}
   * @memberof ChatMessage
   */
  mine?: boolean | null
}
/**
 * ChatMessageの投稿フォーム
 * @export
 * @interface ChatMessageForm
 */
export interface ChatMessageForm {
  /**
   *
   * @type {number}
   * @memberof ChatMessageForm
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof ChatMessageForm
   */
  written_by: number
  /**
   *
   * @type {number}
   * @memberof ChatMessageForm
   */
  mentioned_to: number | null
  /**
   *
   * @type {string}
   * @memberof ChatMessageForm
   */
  body: string
  /**
   *
   * @type {Array<object>}
   * @memberof ChatMessageForm
   */
  files?: Array<object>
}
/**
 * チャット画像
 * @export
 * @interface ChatMessageImage
 */
export interface ChatMessageImage {
  /**
   *
   * @type {number}
   * @memberof ChatMessageImage
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof ChatMessageImage
   */
  chat_message_id?: number
  /**
   *
   * @type {string}
   * @memberof ChatMessageImage
   */
  file_path: string
  /**
   *
   * @type {string}
   * @memberof ChatMessageImage
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof ChatMessageImage
   */
  updated_at: string
}
/**
 * 既読
 * @export
 * @interface ChatMessageRead
 */
export interface ChatMessageRead {
  /**
   *
   * @type {number}
   * @memberof ChatMessageRead
   */
  id: number
  /**
   * 権限値
   * @type {number}
   * @memberof ChatMessageRead
   */
  chat_message_id: number
  /**
   *
   * @type {User}
   * @memberof ChatMessageRead
   */
  member: User
  /**
   *
   * @type {string}
   * @memberof ChatMessageRead
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof ChatMessageRead
   */
  updated_at: string
}
/**
 * チャットルーム
 * @export
 * @interface ChatRoom
 */
export interface ChatRoom {
  /**
   *
   * @type {number}
   * @memberof ChatRoom
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof ChatRoom
   */
  name: string
  /**
   *
   * @type {Array<User>}
   * @memberof ChatRoom
   */
  members: Array<User>
  /**
   *
   * @type {Array<ChatMessage>}
   * @memberof ChatRoom
   */
  messages: Array<ChatMessage>
  /**
   *
   * @type {string}
   * @memberof ChatRoom
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof ChatRoom
   */
  updated_at: string
  /**
   *
   * @type {Array<LastRead>}
   * @memberof ChatRoom
   */
  last_reads?: Array<LastRead>
  /**
   *
   * @type {number}
   * @memberof ChatRoom
   */
  unread_count?: number
}
/**
 * ChatRoomの投稿フォーム
 * @export
 * @interface ChatRoomForm
 */
export interface ChatRoomForm {
  /**
   *
   * @type {number}
   * @memberof ChatRoomForm
   */
  created_by: number | null
  /**
   *
   * @type {string}
   * @memberof ChatRoomForm
   */
  name: string | null
  /**
   *
   * @type {object}
   * @memberof ChatRoomForm
   */
  members?: object
}
/**
 * DefaultError
 * @export
 * @interface DefaultError
 */
export interface DefaultError {
  /**
   * エラーメッセージ
   * @type {string}
   * @memberof DefaultError
   */
  message?: string
}
/**
 * ドキュメントファイル
 * @export
 * @interface DocumentFile
 */
export interface DocumentFile {
  /**
   *
   * @type {number}
   * @memberof DocumentFile
   */
  id: number
  /**
   *
   * @type {User}
   * @memberof DocumentFile
   */
  uploaded_by: User
  /**
   *
   * @type {string}
   * @memberof DocumentFile
   */
  file_path: string
  /**
   *
   * @type {string}
   * @memberof DocumentFile
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof DocumentFile
   */
  updated_at: string
  /**
   *
   * @type {Array<User>}
   * @memberof DocumentFile
   */
  shared_members?: Array<User>
}
/**
 * DocumentFileの投稿フォーム
 * @export
 * @interface DocumentFileForm
 */
export interface DocumentFileForm {
  /**
   *
   * @type {number}
   * @memberof DocumentFileForm
   */
  uploaded_by: number
  /**
   *
   * @type {string}
   * @memberof DocumentFileForm
   */
  file: string
  /**
   *
   * @type {object}
   * @memberof DocumentFileForm
   */
  sharedMembers?: object
  /**
   * 更新時のみ
   * @type {string}
   * @memberof DocumentFileForm
   */
  file_path?: string
}
/**
 * ドキュメントフォルダ
 * @export
 * @interface DocumentFolder
 */
export interface DocumentFolder {
  /**
   *
   * @type {number}
   * @memberof DocumentFolder
   */
  id: number
  /**
   *
   * @type {User}
   * @memberof DocumentFolder
   */
  created_by: User
  /**
   *
   * @type {string}
   * @memberof DocumentFolder
   */
  name: string
  /**
   *
   * @type {Role}
   * @memberof DocumentFolder
   */
  role?: Role
  /**
   *
   * @type {string}
   * @memberof DocumentFolder
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof DocumentFolder
   */
  updated_at: string
}
/**
 * DocumentFolderの投稿フォーム
 * @export
 * @interface DocumentFolderForm
 */
export interface DocumentFolderForm {
  /**
   *
   * @type {number}
   * @memberof DocumentFolderForm
   */
  created_by?: number
  /**
   *
   * @type {string}
   * @memberof DocumentFolderForm
   */
  name: string
  /**
   *
   * @type {number}
   * @memberof DocumentFolderForm
   */
  role_id?: number
}
/**
 * FacialExpression
 * @export
 * @interface FacialExpression
 */
export interface FacialExpression {
  /**
   * エラーメッセージ
   * @type {number}
   * @memberof FacialExpression
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof FacialExpression
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof FacialExpression
   */
  file_path: string
}
/**
 * ForbiddenError
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
  /**
   * エラーメッセージ
   * @type {string}
   * @memberof ForbiddenError
   */
  message?: string
}
/**
 * InvalidError
 * @export
 * @interface InvalidError
 */
export interface InvalidError {
  /**
   * エラーメッセージ
   * @type {string}
   * @memberof InvalidError
   */
  message?: string
  /**
   * フォームアイテムごとのエラーメッセージ
   * @type {{ [key: string]: any; }}
   * @memberof InvalidError
   */
  errors?: { [key: string]: any }
}
/**
 * ユーザごとの最後に読んだメッセージ
 * @export
 * @interface LastRead
 */
export interface LastRead {
  /**
   *
   * @type {number}
   * @memberof LastRead
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof LastRead
   */
  chat_room_id: number
  /**
   *
   * @type {number}
   * @memberof LastRead
   */
  member_id: number
  /**
   *
   * @type {number}
   * @memberof LastRead
   */
  last_message_id: number
  /**
   *
   * @type {string}
   * @memberof LastRead
   */
  created_at?: string
}
/**
 * ログインIDとパスワードのフォーム
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
  /**
   *
   * @type {string}
   * @memberof LoginBody
   */
  login_id: string
  /**
   *
   * @type {string}
   * @memberof LoginBody
   */
  password: string
}
/**
 * ミーティング決定事項
 * @export
 * @interface MeetingDecision
 */
export interface MeetingDecision {
  /**
   *
   * @type {number}
   * @memberof MeetingDecision
   */
  id: number
  /**
   *
   * @type {User}
   * @memberof MeetingDecision
   */
  decided_by: User
  /**
   *
   * @type {User}
   * @memberof MeetingDecision
   */
  written_by: User
  /**
   *
   * @type {string}
   * @memberof MeetingDecision
   */
  subject: string
  /**
   *
   * @type {string}
   * @memberof MeetingDecision
   */
  body: string
  /**
   *
   * @type {Array<Task>}
   * @memberof MeetingDecision
   */
  tasks?: Array<Task>
}
/**
 * ミーティング決定事項フォーム
 * @export
 * @interface MeetingDecisionForm
 */
export interface MeetingDecisionForm {
  /**
   *
   * @type {number}
   * @memberof MeetingDecisionForm
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof MeetingDecisionForm
   */
  decided_by?: number | null
  /**
   *
   * @type {number}
   * @memberof MeetingDecisionForm
   */
  written_by: number
  /**
   *
   * @type {string}
   * @memberof MeetingDecisionForm
   */
  subject?: string | null
  /**
   *
   * @type {string}
   * @memberof MeetingDecisionForm
   */
  body: string
  /**
   *
   * @type {Array<TaskForm>}
   * @memberof MeetingDecisionForm
   */
  tasks?: Array<TaskForm>
  /**
   *
   * @type {number}
   * @memberof MeetingDecisionForm
   */
  flag?: number | null
}
/**
 * 議事録一覧のページ（ページャつき）
 * @export
 * @interface MeetingPage
 */
export interface MeetingPage {
  /**
   *
   * @type {Array<MeetingRecord>}
   * @memberof MeetingPage
   */
  data: Array<MeetingRecord>
  /**
   * 1ページ目のURL
   * @type {string}
   * @memberof MeetingPage
   */
  first_page_url: string
  /**
   * 現在のitemの開始位置
   * @type {number}
   * @memberof MeetingPage
   */
  from: number | null
  /**
   * 最大ページ数
   * @type {number}
   * @memberof MeetingPage
   */
  last_page: number
  /**
   * 最終ページのURL
   * @type {string}
   * @memberof MeetingPage
   */
  last_page_url: string
  /**
   * 次ページのURL
   * @type {string}
   * @memberof MeetingPage
   */
  next_page_url: string | null
  /**
   * 前ページのURL
   * @type {string}
   * @memberof MeetingPage
   */
  path: string
  /**
   * 1ページあたりのアイテム数
   * @type {number}
   * @memberof MeetingPage
   */
  per_page: number
  /**
   * 前ページのURL
   * @type {string}
   * @memberof MeetingPage
   */
  prev_page_url: string | null
  /**
   * 現在のitemの終了位置
   * @type {number}
   * @memberof MeetingPage
   */
  to: number | null
  /**
   * item総数
   * @type {number}
   * @memberof MeetingPage
   */
  total: number
}
/**
 * ミーティング開催場所
 * @export
 * @interface MeetingPlace
 */
export interface MeetingPlace {
  /**
   *
   * @type {number}
   * @memberof MeetingPlace
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof MeetingPlace
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof MeetingPlace
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof MeetingPlace
   */
  updated_at: string
}
/**
 * ミーティングレコード
 * @export
 * @interface MeetingRecord
 */
export interface MeetingRecord {
  /**
   *
   * @type {number}
   * @memberof MeetingRecord
   */
  id: number
  /**
   *
   * @type {User}
   * @memberof MeetingRecord
   */
  recorded_by: User
  /**
   *
   * @type {string}
   * @memberof MeetingRecord
   */
  meeting_date: string
  /**
   *
   * @type {MeetingPlace}
   * @memberof MeetingRecord
   */
  place: MeetingPlace
  /**
   *
   * @type {string}
   * @memberof MeetingRecord
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof MeetingRecord
   */
  summary: string | null
  /**
   *
   * @type {Array<User>}
   * @memberof MeetingRecord
   */
  members: Array<User>
  /**
   *
   * @type {Array<MeetingDecision>}
   * @memberof MeetingRecord
   */
  decisions: Array<MeetingDecision>
  /**
   *
   * @type {string}
   * @memberof MeetingRecord
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof MeetingRecord
   */
  updated_at: string
}
/**
 * 会議議事録投稿フォーム
 * @export
 * @interface MeetingRecordForm
 */
export interface MeetingRecordForm {
  /**
   *
   * @type {number}
   * @memberof MeetingRecordForm
   */
  recorded_by: number
  /**
   *
   * @type {number}
   * @memberof MeetingRecordForm
   */
  place_id?: number | null
  /**
   *
   * @type {string}
   * @memberof MeetingRecordForm
   */
  meeting_date: string
  /**
   *
   * @type {string}
   * @memberof MeetingRecordForm
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof MeetingRecordForm
   */
  summary?: string | null
  /**
   *
   * @type {Array<MeetingDecisionForm>}
   * @memberof MeetingRecordForm
   */
  meeting_decisions?: Array<MeetingDecisionForm>
  /**
   *
   * @type {Array<number>}
   * @memberof MeetingRecordForm
   */
  members?: Array<number>
}
/**
 * 議事録一覧のページ（ページャつき）
 * @export
 * @interface MeetingRecordPage
 */
export interface MeetingRecordPage {
  /**
   *
   * @type {Array<MeetingRecord>}
   * @memberof MeetingRecordPage
   */
  data: Array<MeetingRecord>
  /**
   * 1ページ目のURL
   * @type {string}
   * @memberof MeetingRecordPage
   */
  first_page_url: string
  /**
   * 現在のitemの開始位置
   * @type {number}
   * @memberof MeetingRecordPage
   */
  from: number | null
  /**
   * 最大ページ数
   * @type {number}
   * @memberof MeetingRecordPage
   */
  last_page: number
  /**
   * 最終ページのURL
   * @type {string}
   * @memberof MeetingRecordPage
   */
  last_page_url: string
  /**
   * 次ページのURL
   * @type {string}
   * @memberof MeetingRecordPage
   */
  next_page_url: string | null
  /**
   * 前ページのURL
   * @type {string}
   * @memberof MeetingRecordPage
   */
  path: string
  /**
   * 1ページあたりのアイテム数
   * @type {number}
   * @memberof MeetingRecordPage
   */
  per_page: number
  /**
   * 前ページのURL
   * @type {string}
   * @memberof MeetingRecordPage
   */
  prev_page_url: string | null
  /**
   * 現在のitemの終了位置
   * @type {number}
   * @memberof MeetingRecordPage
   */
  to: number | null
  /**
   * item総数
   * @type {number}
   * @memberof MeetingRecordPage
   */
  total: number
}
/**
 * 共有相手用フォーム
 * @export
 * @interface MemberForm
 */
export interface MemberForm {
  /**
   *
   * @type {number}
   * @memberof MemberForm
   */
  recorded_by: number
  /**
   *
   * @type {number}
   * @memberof MemberForm
   */
  place_id?: number | null
  /**
   *
   * @type {string}
   * @memberof MemberForm
   */
  meeting_date: string
  /**
   *
   * @type {string}
   * @memberof MemberForm
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof MemberForm
   */
  summary?: string | null
  /**
   *
   * @type {Array<MeetingDecisionForm>}
   * @memberof MemberForm
   */
  meeting_decisions?: Array<MeetingDecisionForm>
  /**
   *
   * @type {Array<number>}
   * @memberof MemberForm
   */
  members?: Array<number>
}
/**
 * NotFoundError
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   * エラーメッセージ
   * @type {string}
   * @memberof NotFoundError
   */
  message?: string
}
/**
 * TODOの優先度
 * @export
 * @interface Priority
 */
export interface Priority {
  /**
   *
   * @type {number}
   * @memberof Priority
   */
  id: number
  /**
   * 優先度
   * @type {string}
   * @memberof Priority
   */
  name: string
  /**
   * 優先値
   * @type {number}
   * @memberof Priority
   */
  value: number
  /**
   *
   * @type {string}
   * @memberof Priority
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Priority
   */
  updated_at: string
}
/**
 * TODOの達成度
 * @export
 * @interface Progress
 */
export interface Progress {
  /**
   *
   * @type {number}
   * @memberof Progress
   */
  id: number
  /**
   * 達成度
   * @type {string}
   * @memberof Progress
   */
  name: string
  /**
   * 達成値
   * @type {number}
   * @memberof Progress
   */
  value: number
  /**
   *
   * @type {string}
   * @memberof Progress
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Progress
   */
  updated_at: string
}
/**
 * リアクション
 * @export
 * @interface Reaction
 */
export interface Reaction {
  /**
   *
   * @type {number}
   * @memberof Reaction
   */
  id: number
  /**
   * 権限値
   * @type {number}
   * @memberof Reaction
   */
  chat_message_id: number
  /**
   *
   * @type {User}
   * @memberof Reaction
   */
  member: User
  /**
   *
   * @type {FacialExpression}
   * @memberof Reaction
   */
  facial_expression: FacialExpression
  /**
   *
   * @type {string}
   * @memberof Reaction
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Reaction
   */
  updated_at: string
}
/**
 * ロール
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {number}
   * @memberof Role
   */
  id: number
  /**
   * 権限名
   * @type {string}
   * @memberof Role
   */
  name: string
  /**
   * 権限値
   * @type {number}
   * @memberof Role
   */
  value: number
  /**
   *
   * @type {string}
   * @memberof Role
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Role
   */
  updated_at: string
}
/**
 * スケジュール
 * @export
 * @interface Schedule
 */
export interface Schedule {
  /**
   *
   * @type {number}
   * @memberof Schedule
   */
  id: number
  /**
   *
   * @type {User}
   * @memberof Schedule
   */
  scheduled_by: User
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  start: string
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  end: string
  /**
   *
   * @type {boolean}
   * @memberof Schedule
   */
  is_public?: boolean
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  color?: string | null
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  memo?: string | null
  /**
   *
   * @type {Array<User>}
   * @memberof Schedule
   */
  shared_members: Array<User>
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  updated_at: string
}
/**
 * Scheduleの投稿フォーム
 * @export
 * @interface ScheduleForm
 */
export interface ScheduleForm {
  /**
   *
   * @type {number}
   * @memberof ScheduleForm
   */
  scheduled_by: number
  /**
   *
   * @type {string}
   * @memberof ScheduleForm
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ScheduleForm
   */
  start: string
  /**
   *
   * @type {string}
   * @memberof ScheduleForm
   */
  end: string
  /**
   *
   * @type {boolean}
   * @memberof ScheduleForm
   */
  is_public: boolean | null
  /**
   *
   * @type {string}
   * @memberof ScheduleForm
   */
  color: string | null
  /**
   *
   * @type {string}
   * @memberof ScheduleForm
   */
  memo: string | null
  /**
   *
   * @type {object}
   * @memberof ScheduleForm
   */
  sharedMembers?: object
}
/**
 * 設定ページ
 * @export
 * @interface SettingForm
 */
export interface SettingForm {
  /**
   *
   * @type {object}
   * @memberof SettingForm
   */
  notify_validation?: object
  /**
   *
   * @type {ChangePasswordInput}
   * @memberof SettingForm
   */
  change_password?: ChangePasswordInput
}
/**
 * Tag
 * @export
 * @interface Tag
 */
export interface Tag {
  /**
   *
   * @type {number}
   * @memberof Tag
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  updated_at: string
}
/**
 * Task
 * @export
 * @interface Task
 */
export interface Task {
  /**
   *
   * @type {number}
   * @memberof Task
   */
  id: number
  /**
   *
   * @type {User}
   * @memberof Task
   */
  owner: User
  /**
   *
   * @type {User}
   * @memberof Task
   */
  created_by: User
  /**
   *
   * @type {Priority}
   * @memberof Task
   */
  priority: Priority
  /**
   *
   * @type {Progress}
   * @memberof Task
   */
  progress: Progress
  /**
   *
   * @type {string}
   * @memberof Task
   */
  body: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  time_limit: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  updated_at: string
}
/**
 * TaskDeleteForm
 * @export
 * @interface TaskDeleteForm
 */
export interface TaskDeleteForm {
  /**
   *
   * @type {Array<number>}
   * @memberof TaskDeleteForm
   */
  ids?: Array<number>
}
/**
 * Taskの投稿フォーム
 * @export
 * @interface TaskForm
 */
export interface TaskForm {
  /**
   *
   * @type {number}
   * @memberof TaskForm
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof TaskForm
   */
  owner_id: number
  /**
   *
   * @type {number}
   * @memberof TaskForm
   */
  created_by?: number
  /**
   *
   * @type {number}
   * @memberof TaskForm
   */
  priority_id?: number | null
  /**
   *
   * @type {number}
   * @memberof TaskForm
   */
  progress_id?: number | null
  /**
   *
   * @type {string}
   * @memberof TaskForm
   */
  body: string
  /**
   *
   * @type {string}
   * @memberof TaskForm
   */
  time_limit: string
  /**
   *
   * @type {number}
   * @memberof TaskForm
   */
  flag?: number | null
}
/**
 * タスク一覧のページ（ページャつき）
 * @export
 * @interface TaskPage
 */
export interface TaskPage {
  /**
   *
   * @type {Array<Task>}
   * @memberof TaskPage
   */
  data: Array<Task>
  /**
   * 1ページ目のURL
   * @type {string}
   * @memberof TaskPage
   */
  first_page_url: string
  /**
   * 現在のitemの開始位置
   * @type {number}
   * @memberof TaskPage
   */
  from: number | null
  /**
   * 最大ページ数
   * @type {number}
   * @memberof TaskPage
   */
  last_page: number
  /**
   * 最終ページのURL
   * @type {string}
   * @memberof TaskPage
   */
  last_page_url: string
  /**
   * 次ページのURL
   * @type {string}
   * @memberof TaskPage
   */
  next_page_url: string | null
  /**
   * 前ページのURL
   * @type {string}
   * @memberof TaskPage
   */
  path: string
  /**
   * 1ページあたりのアイテム数
   * @type {number}
   * @memberof TaskPage
   */
  per_page: number
  /**
   * 前ページのURL
   * @type {string}
   * @memberof TaskPage
   */
  prev_page_url: string | null
  /**
   * 現在のitemの終了位置
   * @type {number}
   * @memberof TaskPage
   */
  to: number | null
  /**
   * item総数
   * @type {number}
   * @memberof TaskPage
   */
  total: number
}
/**
 * ユーザーのデータ
 * @export
 * @interface User
 */
export interface User {
  /**
   * ユーザーID
   * @type {number}
   * @memberof User
   */
  id: number
  /**
   * フルネーム
   * @type {string}
   * @memberof User
   */
  full_name: string
  /**
   * 名
   * @type {string}
   * @memberof User
   */
  given_name?: string
  /**
   * 姓
   * @type {string}
   * @memberof User
   */
  family_name?: string
  /**
   * ファイルパス
   * @type {string}
   * @memberof User
   */
  file_path?: string | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  updated_at: string
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * delete task
     * @summary /author/task-DELETE
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [page]
     * @param {string} [status]
     * @param {string} [sortKey]
     * @param {string} [orderBy]
     * @param {TaskDeleteForm} [taskDeleteForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorTask: async (
      authorization?: string,
      origin?: string,
      page?: string,
      status?: string,
      sortKey?: string,
      orderBy?: string,
      taskDeleteForm?: TaskDeleteForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/task`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      if (sortKey !== undefined) {
        localVarQueryParameter['sort_key'] = sortKey
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskDeleteForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete chat message
     * @summary /chat_room/{id}/message/{chat_message_id}-DELETE
     * @param {string} id
     * @param {string} chatMessageId
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatMessageId: async (
      id: string,
      chatMessageId: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteChatMessageId', 'id', id)
      // verify required parameter 'chatMessageId' is not null or undefined
      assertParamExists('deleteChatMessageId', 'chatMessageId', chatMessageId)
      const localVarPath = `/chat_room/{id}/message/{chat_message_id}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(
          `{${'chat_message_id'}}`,
          encodeURIComponent(String(chatMessageId))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete chat room
     * @summary /chat_room/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatRoomId: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteChatRoomId', 'id', id)
      const localVarPath = `/chat_room/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete meeting record
     * @summary /meeting_record/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [keyword]
     * @param {string} [sortKey]
     * @param {string} [meetingDate]
     * @param {string} [count]
     * @param {string} [orderBy]
     * @param {string} [onlyBookmark]
     * @param {string} [page]
     * @param {string} [onlyMe]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMeetingRecordId: async (
      id: string,
      authorization?: string,
      origin?: string,
      keyword?: string,
      sortKey?: string,
      meetingDate?: string,
      count?: string,
      orderBy?: string,
      onlyBookmark?: string,
      page?: string,
      onlyMe?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteMeetingRecordId', 'id', id)
      const localVarPath = `/meeting_record/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (keyword !== undefined) {
        localVarQueryParameter['keyword'] = keyword
      }

      if (sortKey !== undefined) {
        localVarQueryParameter['sort_key'] = sortKey
      }

      if (meetingDate !== undefined) {
        localVarQueryParameter['meeting_date'] = meetingDate
      }

      if (count !== undefined) {
        localVarQueryParameter['count'] = count
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy
      }

      if (onlyBookmark !== undefined) {
        localVarQueryParameter['only_bookmark'] = onlyBookmark
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (onlyMe !== undefined) {
        localVarQueryParameter['only_me'] = onlyMe
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete schedule
     * @summary /schedule/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteScheduleId: async (
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteScheduleId', 'id', id)
      const localVarPath = `/schedule/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete meeting record
     * @summary /task/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskId: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteTaskId', 'id', id)
      const localVarPath = `/task/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return activity on user
     * @summary /user/{id}/activity-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityByUser: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getActivityByUser', 'id', id)
      const localVarPath = `/user/{id}/activity`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return chat rooms author has joined
     * @summary /author/chat_room-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorChatRoom: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/chat_room`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return author daily schedule
     * @summary /author/schedule/daily-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorDailySchedule: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/schedule/daily`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return author busy task
     * @summary /author/task/busy-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBusyTask: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/task/busy`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return unread message list
     * @summary /author/chat_message/unread/recently-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatMessageUnread: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/chat_message/unread/recently`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return chat room by id
     * @summary /chat_room/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomId: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getChatRoomId', 'id', id)
      const localVarPath = `/chat_room/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return current admin
     * @summary /admin/current-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentAdmin: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/current`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return current auth object
     * @summary /user-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/current`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return current auth object with chat
     * @summary /user/current/chat_rooms-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserWithChat: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/current/chat_rooms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return document folder
     * @summary /docuement_folder-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentFolder: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/document_folder`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return document folder by id
     * @summary /document_folder/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentFolderId: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDocumentFolderId', 'id', id)
      const localVarPath = `/document_folder/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return meeting place list
     * @summary /meeting_place-GET
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingPlace: async (
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/meeting_place`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return meeting record
     * @summary /meeting_record-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [keyword]
     * @param {string} [sortKey]
     * @param {string} [meetingDate]
     * @param {string} [count]
     * @param {string} [orderBy]
     * @param {string} [onlyBookmark]
     * @param {string} [page]
     * @param {string} [onlyMe]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingRecord: async (
      authorization?: string,
      origin?: string,
      keyword?: string,
      sortKey?: string,
      meetingDate?: string,
      count?: string,
      orderBy?: string,
      onlyBookmark?: string,
      page?: string,
      onlyMe?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/meeting_record`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (keyword !== undefined) {
        localVarQueryParameter['keyword'] = keyword
      }

      if (sortKey !== undefined) {
        localVarQueryParameter['sort_key'] = sortKey
      }

      if (meetingDate !== undefined) {
        localVarQueryParameter['meeting_date'] = meetingDate
      }

      if (count !== undefined) {
        localVarQueryParameter['count'] = count
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy
      }

      if (onlyBookmark !== undefined) {
        localVarQueryParameter['only_bookmark'] = onlyBookmark
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (onlyMe !== undefined) {
        localVarQueryParameter['only_me'] = onlyMe
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return meeting record by id
     * @summary /meeting_record/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingRecordId: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getMeetingRecordId', 'id', id)
      const localVarPath = `/meeting_record/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return priority list
     * @summary /priority-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPriority: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/priority`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return progress list
     * @summary /progress-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgress: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/progress`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return author daily schedule
     * @summary /author/meeting_record/recently-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentAuthorMeetingRecord: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/meeting_record/recently`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoot: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return schedule
     * @summary /schedule-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedule: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/schedule`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return schedule by id
     * @summary /schedule/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduleId: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getScheduleId', 'id', id)
      const localVarPath = `/schedule/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return author task
     * @summary /author/task-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [page]
     * @param {string} [status]
     * @param {string} [orderBy]
     * @param {string} [sortKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask: async (
      authorization?: string,
      origin?: string,
      page?: string,
      status?: string,
      orderBy?: string,
      sortKey?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/task`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy
      }

      if (sortKey !== undefined) {
        localVarQueryParameter['sort_key'] = sortKey
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return task
     * @summary /task-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskPage: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/task`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 会議の参加者を入力するドロップダウンリスト等に使用
     * @summary /user-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return schedule on user
     * @summary /user/{id}/schedule-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdSchedule: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUserIdSchedule', 'id', id)
      const localVarPath = `/user/{id}/schedule`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /user/current-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionCurrentUser: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/current`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /user/current/chat_rooms-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionCurrentUserWithChat: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/current/chat_rooms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /meeting_record/{id}/bookmark-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionMeetingRecordIBookmark: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionMeetingRecordIBookmark', 'id', id)
      const localVarPath = `/meeting_record/{id}/bookmark`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary user profile
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionProfile: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionProfile', 'id', id)
      const localVarPath = `/user/{id}/profile`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /task/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionTaskId: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionTaskId', 'id', id)
      const localVarPath = `/task/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /user-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionUser: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /user/{id}/activity-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionUserActivityRead: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionUserActivityRead', 'id', id)
      const localVarPath = `/user/{id}/activity/read`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /user/{id}/setting-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionUserSetting: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionUserSetting', 'id', id)
      const localVarPath = `/user/{id}/setting`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /author/task/busy-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorBusyTask: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/task/busy`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorChatRoom: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/chat_room`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorDailySchedule: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/schedule/daily`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /author/task-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorTask: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/task`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsBlogAsset: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/blog_asset`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /chat_room/{id}/message-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessage: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsChatMessage', 'id', id)
      const localVarPath = `/chat_room/{id}/message`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /chat_room/{id}/message/{chat_message_id}-OPTIONS
     * @param {string} id
     * @param {string} chatMessageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessageId: async (
      id: string,
      chatMessageId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsChatMessageId', 'id', id)
      // verify required parameter 'chatMessageId' is not null or undefined
      assertParamExists('optionsChatMessageId', 'chatMessageId', chatMessageId)
      const localVarPath = `/chat_room/{id}/message/{chat_message_id}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(
          `{${'chat_message_id'}}`,
          encodeURIComponent(String(chatMessageId))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /chat_room/{chat_room_id}/message-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessageRead: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsChatMessageRead', 'id', id)
      const localVarPath = `/chat_room/{id}/read`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /author/chat_message/unread/recently-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessageUnread: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/chat_message/unread/recently`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatRoom: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/chat_room`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /chat_room/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatRoomId: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsChatRoomId', 'id', id)
      const localVarPath = `/chat_room/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /admin/current-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsCurrentAdmin: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/current`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /docuement_folder-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsDocumentFolder: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/document_folder`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /document_folder/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsDocumentFolderId: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsDocumentFolderId', 'id', id)
      const localVarPath = `/document_folder/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /meeting_place-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsMeetingPlace: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/meeting_place`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /meeting_record-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsMeetingRecord: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/meeting_record`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preflight
     * @summary /meeting_record/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsMeetingRecordId: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsMeetingRecordId', 'id', id)
      const localVarPath = `/meeting_record/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /user/{id}/notify_validation-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsNotifyValidation: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsNotifyValidation', 'id', id)
      const localVarPath = `/user/{id}/notify_validation`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsPriority: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/priority`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsProgress: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/progress`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /author/meeting_record/recently-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsRecentAuthorMeetingRecord: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/author/meeting_record/recently`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsRoot: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /schedule-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsSchedule: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/schedule`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /document_folder/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsScheduleId: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsScheduleId', 'id', id)
      const localVarPath = `/schedule/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /task-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsTask: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/task`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /user/{id}/schedule-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsUserActivity: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsUserActivity', 'id', id)
      const localVarPath = `/user/{id}/activity`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /user/{id}/schedule-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsUserSchedule: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('optionsUserSchedule', 'id', id)
      const localVarPath = `/user/{id}/schedule`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /blog_asset-POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postBlogAsset: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/blog_asset`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * post chat message
     * @summary /chat_room/{id}/message-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ChatMessageForm} [chatMessageForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChatMessage: async (
      id: string,
      authorization?: string,
      origin?: string,
      chatMessageForm?: ChatMessageForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('postChatMessage', 'id', id)
      const localVarPath = `/chat_room/{id}/message`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        chatMessageForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * post chat read
     * @summary /chat_room/{id}/read-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChatRead: async (
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('postChatRead', 'id', id)
      const localVarPath = `/chat_room/{id}/read`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * return params
     * @summary /chat_room-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ChatRoomForm} [chatRoomForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChatRoom: async (
      authorization?: string,
      origin?: string,
      chatRoomForm?: ChatRoomForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/chat_room`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        chatRoomForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * post document folder
     * @summary /docuement_folder-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {DocumentFolderForm} [documentFolderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDocumentFolder: async (
      authorization?: string,
      origin?: string,
      documentFolderForm?: DocumentFolderForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/document_folder`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        documentFolderForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * post meeting record
     * @summary /meeting_record-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {MeetingRecordForm} [meetingRecordForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMeetingRecord: async (
      authorization?: string,
      origin?: string,
      meetingRecordForm?: MeetingRecordForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/meeting_record`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        meetingRecordForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary /meeting_record/{id}/bookmark-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMeetingRecordBookmark: async (
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('postMeetingRecordBookmark', 'id', id)
      const localVarPath = `/meeting_record/{id}/bookmark`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * post schedule
     * @summary /schedule-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ScheduleForm} [scheduleForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSchedule: async (
      authorization?: string,
      origin?: string,
      scheduleForm?: ScheduleForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/schedule`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        scheduleForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * post task
     * @summary /task-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {TaskForm} [taskForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTask: async (
      authorization?: string,
      origin?: string,
      taskForm?: TaskForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/task`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update chat message
     * @summary /chat_room/{id}/message/{chat_message_id}-PUT
     * @param {string} chatMessageId
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {ChatMessageForm} [chatMessageForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putChatMessageId: async (
      chatMessageId: string,
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      chatMessageForm?: ChatMessageForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chatMessageId' is not null or undefined
      assertParamExists('putChatMessageId', 'chatMessageId', chatMessageId)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putChatMessageId', 'id', id)
      const localVarPath = `/chat_room/{id}/message/{chat_message_id}`
        .replace(
          `{${'chat_message_id'}}`,
          encodeURIComponent(String(chatMessageId))
        )
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        chatMessageForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update chat room data
     * @summary /chat_room/{id}-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {ChatRoomForm} [chatRoomForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putChatRoomId: async (
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      chatRoomForm?: ChatRoomForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putChatRoomId', 'id', id)
      const localVarPath = `/chat_room/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        chatRoomForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update document folder
     * @summary /document_folder/{id}-PUT
     * @param {string} id
     * @param {string} [origin]
     * @param {string} [authorization]
     * @param {string} [xHTTPMethodOverride]
     * @param {DocumentFolderForm} [documentFolderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDocumentFolderId: async (
      id: string,
      origin?: string,
      authorization?: string,
      xHTTPMethodOverride?: string,
      documentFolderForm?: DocumentFolderForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putDocumentFolderId', 'id', id)
      const localVarPath = `/document_folder/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        documentFolderForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * bookmark meeting record
     * @summary /meeting_record/{id}/bookmark-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMeetingRecordBookmark: async (
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putMeetingRecordBookmark', 'id', id)
      const localVarPath = `/meeting_record/{id}/bookmark`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update meeting record
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {MeetingRecordForm} [meetingRecordForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMeetingRecordId: async (
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      meetingRecordForm?: MeetingRecordForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putMeetingRecordId', 'id', id)
      const localVarPath = `/meeting_record/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        meetingRecordForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * プロフィールの更新
     * @summary /user/{id}/profile-PUT
     * @param {string} id
     * @param {string} familyName
     * @param {string} givenName
     * @param {string} familyNameKana
     * @param {string} givenNameKana
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {boolean} [deleteFlag]
     * @param {any} [file]
     * @param {boolean} [changePassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putProfile: async (
      id: string,
      familyName: string,
      givenName: string,
      familyNameKana: string,
      givenNameKana: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      deleteFlag?: boolean,
      file?: any,
      changePassword?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putProfile', 'id', id)
      // verify required parameter 'familyName' is not null or undefined
      assertParamExists('putProfile', 'familyName', familyName)
      // verify required parameter 'givenName' is not null or undefined
      assertParamExists('putProfile', 'givenName', givenName)
      // verify required parameter 'familyNameKana' is not null or undefined
      assertParamExists('putProfile', 'familyNameKana', familyNameKana)
      // verify required parameter 'givenNameKana' is not null or undefined
      assertParamExists('putProfile', 'givenNameKana', givenNameKana)
      const localVarPath = `/user/{id}/profile`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      if (familyName !== undefined) {
        localVarFormParams.append('family_name', familyName as any)
      }

      if (givenName !== undefined) {
        localVarFormParams.append('given_name', givenName as any)
      }

      if (familyNameKana !== undefined) {
        localVarFormParams.append('family_name_kana', familyNameKana as any)
      }

      if (givenNameKana !== undefined) {
        localVarFormParams.append('given_name_kana', givenNameKana as any)
      }

      if (deleteFlag !== undefined) {
        localVarFormParams.append('delete_flag', deleteFlag as any)
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      if (changePassword !== undefined) {
        localVarFormParams.append('change_password', changePassword as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update schedule
     * @summary /schedule/{id}-PUT
     * @param {string} id
     * @param {string} [origin]
     * @param {string} [authorization]
     * @param {string} [xHTTPMethodOverride]
     * @param {ScheduleForm} [scheduleForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putScheduleId: async (
      id: string,
      origin?: string,
      authorization?: string,
      xHTTPMethodOverride?: string,
      scheduleForm?: ScheduleForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putScheduleId', 'id', id)
      const localVarPath = `/schedule/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        scheduleForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update task
     * @summary /task/{id}-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {TaskForm} [taskForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTaskId: async (
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      taskForm?: TaskForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putTaskId', 'id', id)
      const localVarPath = `/task/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update activity read
     * @summary /user/{id}/activity/read-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserActivityRead: async (
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putUserActivityRead', 'id', id)
      const localVarPath = `/user/{id}/activity/read`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update user notify validation
     * @summary /user/{id}/notify_validation-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserNotifyValidation: async (
      id: string,
      authorization?: string,
      origin?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putUserNotifyValidation', 'id', id)
      const localVarPath = `/user/{id}/notify_validation`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * customize user settings
     * @summary /user/{id}/setting-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {SettingForm} [settingForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting: async (
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      settingForm?: SettingForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('putUserSetting', 'id', id)
      const localVarPath = `/user/{id}/setting`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication job-support-authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization)
      }

      if (origin !== undefined && origin !== null) {
        localVarHeaderParameter['Origin'] = String(origin)
      }

      if (xHTTPMethodOverride !== undefined && xHTTPMethodOverride !== null) {
        localVarHeaderParameter['X-HTTP-Method-Override'] =
          String(xHTTPMethodOverride)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        settingForm,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * delete task
     * @summary /author/task-DELETE
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [page]
     * @param {string} [status]
     * @param {string} [sortKey]
     * @param {string} [orderBy]
     * @param {TaskDeleteForm} [taskDeleteForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAuthorTask(
      authorization?: string,
      origin?: string,
      page?: string,
      status?: string,
      sortKey?: string,
      orderBy?: string,
      taskDeleteForm?: TaskDeleteForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskPage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAuthorTask(
          authorization,
          origin,
          page,
          status,
          sortKey,
          orderBy,
          taskDeleteForm,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * delete chat message
     * @summary /chat_room/{id}/message/{chat_message_id}-DELETE
     * @param {string} id
     * @param {string} chatMessageId
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChatMessageId(
      id: string,
      chatMessageId: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteChatMessageId(
          id,
          chatMessageId,
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * delete chat room
     * @summary /chat_room/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChatRoomId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoom>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteChatRoomId(
          id,
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * delete meeting record
     * @summary /meeting_record/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [keyword]
     * @param {string} [sortKey]
     * @param {string} [meetingDate]
     * @param {string} [count]
     * @param {string} [orderBy]
     * @param {string} [onlyBookmark]
     * @param {string} [page]
     * @param {string} [onlyMe]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMeetingRecordId(
      id: string,
      authorization?: string,
      origin?: string,
      keyword?: string,
      sortKey?: string,
      meetingDate?: string,
      count?: string,
      orderBy?: string,
      onlyBookmark?: string,
      page?: string,
      onlyMe?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MeetingRecordPage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteMeetingRecordId(
          id,
          authorization,
          origin,
          keyword,
          sortKey,
          meetingDate,
          count,
          orderBy,
          onlyBookmark,
          page,
          onlyMe,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * delete schedule
     * @summary /schedule/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteScheduleId(
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteScheduleId(
          id,
          authorization,
          origin,
          body,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * delete meeting record
     * @summary /task/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTaskId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskPage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskId(
        id,
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return activity on user
     * @summary /user/{id}/activity-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivityByUser(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Activity>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getActivityByUser(
          id,
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return chat rooms author has joined
     * @summary /author/chat_room-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthorChatRoom(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatRoom>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAuthorChatRoom(
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return author daily schedule
     * @summary /author/schedule/daily-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthorDailySchedule(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Schedule>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAuthorDailySchedule(
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return author busy task
     * @summary /author/task/busy-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBusyTask(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskPage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBusyTask(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return unread message list
     * @summary /author/chat_message/unread/recently-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChatMessageUnread(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatMessage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getChatMessageUnread(
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return chat room by id
     * @summary /chat_room/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChatRoomId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoom>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChatRoomId(
        id,
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return current admin
     * @summary /admin/current-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentAdmin(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Admin>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentAdmin(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return current auth object
     * @summary /user-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUser(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return current auth object with chat
     * @summary /user/current/chat_rooms-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUserWithChat(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCurrentUserWithChat(
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return document folder
     * @summary /docuement_folder-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDocumentFolder(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<DocumentFolder>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDocumentFolder(
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return document folder by id
     * @summary /document_folder/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDocumentFolderId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<DocumentFolder>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDocumentFolderId(
          id,
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return meeting place list
     * @summary /meeting_place-GET
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMeetingPlace(
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MeetingPlace>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMeetingPlace(
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return meeting record
     * @summary /meeting_record-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [keyword]
     * @param {string} [sortKey]
     * @param {string} [meetingDate]
     * @param {string} [count]
     * @param {string} [orderBy]
     * @param {string} [onlyBookmark]
     * @param {string} [page]
     * @param {string} [onlyMe]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMeetingRecord(
      authorization?: string,
      origin?: string,
      keyword?: string,
      sortKey?: string,
      meetingDate?: string,
      count?: string,
      orderBy?: string,
      onlyBookmark?: string,
      page?: string,
      onlyMe?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MeetingRecordPage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMeetingRecord(
          authorization,
          origin,
          keyword,
          sortKey,
          meetingDate,
          count,
          orderBy,
          onlyBookmark,
          page,
          onlyMe,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return meeting record by id
     * @summary /meeting_record/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMeetingRecordId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRecord>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMeetingRecordId(
          id,
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return priority list
     * @summary /priority-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPriority(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Priority>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPriority(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return progress list
     * @summary /progress-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProgress(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Progress>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProgress(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return author daily schedule
     * @summary /author/meeting_record/recently-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecentAuthorMeetingRecord(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MeetingRecord>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecentAuthorMeetingRecord(
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoot(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoot(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return schedule
     * @summary /schedule-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSchedule(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Schedule>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return schedule by id
     * @summary /schedule/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduleId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Schedule>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleId(
        id,
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return author task
     * @summary /author/task-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [page]
     * @param {string} [status]
     * @param {string} [orderBy]
     * @param {string} [sortKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTask(
      authorization?: string,
      origin?: string,
      page?: string,
      status?: string,
      orderBy?: string,
      sortKey?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskPage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(
        authorization,
        origin,
        page,
        status,
        orderBy,
        sortKey,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return task
     * @summary /task-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskPage(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TaskPage>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskPage(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * 会議の参加者を入力するドロップダウンリスト等に使用
     * @summary /user-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        authorization,
        origin,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return schedule on user
     * @summary /user/{id}/schedule-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserIdSchedule(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Schedule>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserIdSchedule(
          id,
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /user/current-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionCurrentUser(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionCurrentUser(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /user/current/chat_rooms-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionCurrentUserWithChat(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionCurrentUserWithChat(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /meeting_record/{id}/bookmark-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionMeetingRecordIBookmark(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionMeetingRecordIBookmark(
          id,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary user profile
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionProfile(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionProfile(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /task/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionTaskId(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionTaskId(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /user-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionUser(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionUser(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /user/{id}/activity-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionUserActivityRead(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionUserActivityRead(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /user/{id}/setting-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionUserSetting(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionUserSetting(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /author/task/busy-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsAuthorBusyTask(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsAuthorBusyTask(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsAuthorChatRoom(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsAuthorChatRoom(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsAuthorDailySchedule(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsAuthorDailySchedule(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /author/task-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsAuthorTask(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsAuthorTask(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsBlogAsset(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsBlogAsset(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /chat_room/{id}/message-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsChatMessage(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsChatMessage(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /chat_room/{id}/message/{chat_message_id}-OPTIONS
     * @param {string} id
     * @param {string} chatMessageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsChatMessageId(
      id: string,
      chatMessageId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsChatMessageId(
          id,
          chatMessageId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /chat_room/{chat_room_id}/message-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsChatMessageRead(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsChatMessageRead(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /author/chat_message/unread/recently-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsChatMessageUnread(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsChatMessageUnread(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsChatRoom(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionsChatRoom(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /chat_room/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsChatRoomId(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsChatRoomId(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /admin/current-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsCurrentAdmin(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsCurrentAdmin(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /docuement_folder-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsDocumentFolder(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsDocumentFolder(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /document_folder/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsDocumentFolderId(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsDocumentFolderId(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /meeting_place-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsMeetingPlace(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsMeetingPlace(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /meeting_record-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsMeetingRecord(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsMeetingRecord(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * preflight
     * @summary /meeting_record/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsMeetingRecordId(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsMeetingRecordId(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /user/{id}/notify_validation-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsNotifyValidation(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsNotifyValidation(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsPriority(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionsPriority(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsProgress(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionsProgress(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /author/meeting_record/recently-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsRecentAuthorMeetingRecord(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsRecentAuthorMeetingRecord(
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsRoot(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionsRoot(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /schedule-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsSchedule(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionsSchedule(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /document_folder/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsScheduleId(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsScheduleId(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /task-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsTask(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optionsTask(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /user/{id}/schedule-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsUserActivity(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsUserActivity(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /user/{id}/schedule-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optionsUserSchedule(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optionsUserSchedule(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /blog_asset-POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postBlogAsset(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postBlogAsset(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * post chat message
     * @summary /chat_room/{id}/message-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ChatMessageForm} [chatMessageForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postChatMessage(
      id: string,
      authorization?: string,
      origin?: string,
      chatMessageForm?: ChatMessageForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postChatMessage(
        id,
        authorization,
        origin,
        chatMessageForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * post chat read
     * @summary /chat_room/{id}/read-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postChatRead(
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoom>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postChatRead(
        id,
        authorization,
        origin,
        body,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * return params
     * @summary /chat_room-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ChatRoomForm} [chatRoomForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postChatRoom(
      authorization?: string,
      origin?: string,
      chatRoomForm?: ChatRoomForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoom>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postChatRoom(
        authorization,
        origin,
        chatRoomForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * post document folder
     * @summary /docuement_folder-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {DocumentFolderForm} [documentFolderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDocumentFolder(
      authorization?: string,
      origin?: string,
      documentFolderForm?: DocumentFolderForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFolder>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDocumentFolder(
          authorization,
          origin,
          documentFolderForm,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * post meeting record
     * @summary /meeting_record-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {MeetingRecordForm} [meetingRecordForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postMeetingRecord(
      authorization?: string,
      origin?: string,
      meetingRecordForm?: MeetingRecordForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRecord>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postMeetingRecord(
          authorization,
          origin,
          meetingRecordForm,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary /meeting_record/{id}/bookmark-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postMeetingRecordBookmark(
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRecord>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postMeetingRecordBookmark(
          id,
          authorization,
          origin,
          body,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * post schedule
     * @summary /schedule-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ScheduleForm} [scheduleForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSchedule(
      authorization?: string,
      origin?: string,
      scheduleForm?: ScheduleForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postSchedule(
        authorization,
        origin,
        scheduleForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * post task
     * @summary /task-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {TaskForm} [taskForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTask(
      authorization?: string,
      origin?: string,
      taskForm?: TaskForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postTask(
        authorization,
        origin,
        taskForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update chat message
     * @summary /chat_room/{id}/message/{chat_message_id}-PUT
     * @param {string} chatMessageId
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {ChatMessageForm} [chatMessageForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putChatMessageId(
      chatMessageId: string,
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      chatMessageForm?: ChatMessageForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putChatMessageId(
          chatMessageId,
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          chatMessageForm,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update chat room data
     * @summary /chat_room/{id}-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {ChatRoomForm} [chatRoomForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putChatRoomId(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      chatRoomForm?: ChatRoomForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoom>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putChatRoomId(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        chatRoomForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update document folder
     * @summary /document_folder/{id}-PUT
     * @param {string} id
     * @param {string} [origin]
     * @param {string} [authorization]
     * @param {string} [xHTTPMethodOverride]
     * @param {DocumentFolderForm} [documentFolderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putDocumentFolderId(
      id: string,
      origin?: string,
      authorization?: string,
      xHTTPMethodOverride?: string,
      documentFolderForm?: DocumentFolderForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFolder>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putDocumentFolderId(
          id,
          origin,
          authorization,
          xHTTPMethodOverride,
          documentFolderForm,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * bookmark meeting record
     * @summary /meeting_record/{id}/bookmark-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putMeetingRecordBookmark(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRecord>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putMeetingRecordBookmark(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          body,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update meeting record
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {MeetingRecordForm} [meetingRecordForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putMeetingRecordId(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      meetingRecordForm?: MeetingRecordForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRecord>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putMeetingRecordId(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          meetingRecordForm,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * プロフィールの更新
     * @summary /user/{id}/profile-PUT
     * @param {string} id
     * @param {string} familyName
     * @param {string} givenName
     * @param {string} familyNameKana
     * @param {string} givenNameKana
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {boolean} [deleteFlag]
     * @param {any} [file]
     * @param {boolean} [changePassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putProfile(
      id: string,
      familyName: string,
      givenName: string,
      familyNameKana: string,
      givenNameKana: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      deleteFlag?: boolean,
      file?: any,
      changePassword?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putProfile(
        id,
        familyName,
        givenName,
        familyNameKana,
        givenNameKana,
        authorization,
        origin,
        xHTTPMethodOverride,
        deleteFlag,
        file,
        changePassword,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update schedule
     * @summary /schedule/{id}-PUT
     * @param {string} id
     * @param {string} [origin]
     * @param {string} [authorization]
     * @param {string} [xHTTPMethodOverride]
     * @param {ScheduleForm} [scheduleForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putScheduleId(
      id: string,
      origin?: string,
      authorization?: string,
      xHTTPMethodOverride?: string,
      scheduleForm?: ScheduleForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putScheduleId(
        id,
        origin,
        authorization,
        xHTTPMethodOverride,
        scheduleForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update task
     * @summary /task/{id}-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {TaskForm} [taskForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putTaskId(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      taskForm?: TaskForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putTaskId(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        taskForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update activity read
     * @summary /user/{id}/activity/read-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserActivityRead(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putUserActivityRead(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          body,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * update user notify validation
     * @summary /user/{id}/notify_validation-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserNotifyValidation(
      id: string,
      authorization?: string,
      origin?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putUserNotifyValidation(
          id,
          authorization,
          origin,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * customize user settings
     * @summary /user/{id}/setting-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {SettingForm} [settingForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserSetting(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      settingForm?: SettingForm,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putUserSetting(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        settingForm,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * delete task
     * @summary /author/task-DELETE
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [page]
     * @param {string} [status]
     * @param {string} [sortKey]
     * @param {string} [orderBy]
     * @param {TaskDeleteForm} [taskDeleteForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorTask(
      authorization?: string,
      origin?: string,
      page?: string,
      status?: string,
      sortKey?: string,
      orderBy?: string,
      taskDeleteForm?: TaskDeleteForm,
      options?: any
    ): AxiosPromise<TaskPage> {
      return localVarFp
        .deleteAuthorTask(
          authorization,
          origin,
          page,
          status,
          sortKey,
          orderBy,
          taskDeleteForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * delete chat message
     * @summary /chat_room/{id}/message/{chat_message_id}-DELETE
     * @param {string} id
     * @param {string} chatMessageId
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatMessageId(
      id: string,
      chatMessageId: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<ChatMessage> {
      return localVarFp
        .deleteChatMessageId(id, chatMessageId, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * delete chat room
     * @summary /chat_room/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatRoomId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<ChatRoom> {
      return localVarFp
        .deleteChatRoomId(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * delete meeting record
     * @summary /meeting_record/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [keyword]
     * @param {string} [sortKey]
     * @param {string} [meetingDate]
     * @param {string} [count]
     * @param {string} [orderBy]
     * @param {string} [onlyBookmark]
     * @param {string} [page]
     * @param {string} [onlyMe]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMeetingRecordId(
      id: string,
      authorization?: string,
      origin?: string,
      keyword?: string,
      sortKey?: string,
      meetingDate?: string,
      count?: string,
      orderBy?: string,
      onlyBookmark?: string,
      page?: string,
      onlyMe?: string,
      options?: any
    ): AxiosPromise<MeetingRecordPage> {
      return localVarFp
        .deleteMeetingRecordId(
          id,
          authorization,
          origin,
          keyword,
          sortKey,
          meetingDate,
          count,
          orderBy,
          onlyBookmark,
          page,
          onlyMe,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * delete schedule
     * @summary /schedule/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteScheduleId(
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options?: any
    ): AxiosPromise<Schedule> {
      return localVarFp
        .deleteScheduleId(id, authorization, origin, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * delete meeting record
     * @summary /task/{id}-DELETE
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<TaskPage> {
      return localVarFp
        .deleteTaskId(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return activity on user
     * @summary /user/{id}/activity-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityByUser(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<Activity>> {
      return localVarFp
        .getActivityByUser(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return chat rooms author has joined
     * @summary /author/chat_room-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorChatRoom(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<ChatRoom>> {
      return localVarFp
        .getAuthorChatRoom(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return author daily schedule
     * @summary /author/schedule/daily-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorDailySchedule(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<Schedule>> {
      return localVarFp
        .getAuthorDailySchedule(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return author busy task
     * @summary /author/task/busy-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBusyTask(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<TaskPage> {
      return localVarFp
        .getBusyTask(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return unread message list
     * @summary /author/chat_message/unread/recently-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatMessageUnread(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<ChatMessage>> {
      return localVarFp
        .getChatMessageUnread(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return chat room by id
     * @summary /chat_room/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<ChatRoom> {
      return localVarFp
        .getChatRoomId(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return current admin
     * @summary /admin/current-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentAdmin(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Admin> {
      return localVarFp
        .getCurrentAdmin(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return current auth object
     * @summary /user-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .getCurrentUser(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return current auth object with chat
     * @summary /user/current/chat_rooms-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserWithChat(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .getCurrentUserWithChat(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return document folder
     * @summary /docuement_folder-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentFolder(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<DocumentFolder>> {
      return localVarFp
        .getDocumentFolder(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return document folder by id
     * @summary /document_folder/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentFolderId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<DocumentFolder>> {
      return localVarFp
        .getDocumentFolderId(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return meeting place list
     * @summary /meeting_place-GET
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingPlace(
      origin?: string,
      options?: any
    ): AxiosPromise<Array<MeetingPlace>> {
      return localVarFp
        .getMeetingPlace(origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return meeting record
     * @summary /meeting_record-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [keyword]
     * @param {string} [sortKey]
     * @param {string} [meetingDate]
     * @param {string} [count]
     * @param {string} [orderBy]
     * @param {string} [onlyBookmark]
     * @param {string} [page]
     * @param {string} [onlyMe]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingRecord(
      authorization?: string,
      origin?: string,
      keyword?: string,
      sortKey?: string,
      meetingDate?: string,
      count?: string,
      orderBy?: string,
      onlyBookmark?: string,
      page?: string,
      onlyMe?: string,
      options?: any
    ): AxiosPromise<Array<MeetingRecordPage>> {
      return localVarFp
        .getMeetingRecord(
          authorization,
          origin,
          keyword,
          sortKey,
          meetingDate,
          count,
          orderBy,
          onlyBookmark,
          page,
          onlyMe,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * return meeting record by id
     * @summary /meeting_record/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingRecordId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<MeetingRecord> {
      return localVarFp
        .getMeetingRecordId(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return priority list
     * @summary /priority-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPriority(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<Priority>> {
      return localVarFp
        .getPriority(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return progress list
     * @summary /progress-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgress(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<Progress>> {
      return localVarFp
        .getProgress(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return author daily schedule
     * @summary /author/meeting_record/recently-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentAuthorMeetingRecord(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<MeetingRecord>> {
      return localVarFp
        .getRecentAuthorMeetingRecord(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoot(options?: any): AxiosPromise<object> {
      return localVarFp
        .getRoot(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return schedule
     * @summary /schedule-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedule(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<Schedule>> {
      return localVarFp
        .getSchedule(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return schedule by id
     * @summary /schedule/{id}-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduleId(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<Schedule>> {
      return localVarFp
        .getScheduleId(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return author task
     * @summary /author/task-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [page]
     * @param {string} [status]
     * @param {string} [orderBy]
     * @param {string} [sortKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(
      authorization?: string,
      origin?: string,
      page?: string,
      status?: string,
      orderBy?: string,
      sortKey?: string,
      options?: any
    ): AxiosPromise<TaskPage> {
      return localVarFp
        .getTask(authorization, origin, page, status, orderBy, sortKey, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return task
     * @summary /task-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskPage(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<TaskPage>> {
      return localVarFp
        .getTaskPage(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 会議の参加者を入力するドロップダウンリスト等に使用
     * @summary /user-GET
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .getUser(authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return schedule on user
     * @summary /user/{id}/schedule-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdSchedule(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<Array<Schedule>> {
      return localVarFp
        .getUserIdSchedule(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /user/current-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionCurrentUser(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionCurrentUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /user/current/chat_rooms-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionCurrentUserWithChat(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionCurrentUserWithChat(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /meeting_record/{id}/bookmark-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionMeetingRecordIBookmark(
      id: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .optionMeetingRecordIBookmark(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary user profile
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionProfile(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionProfile(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /task/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionTaskId(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionTaskId(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /user-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionUser(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /user/{id}/activity-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionUserActivityRead(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionUserActivityRead(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /user/{id}/setting-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionUserSetting(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionUserSetting(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /author/task/busy-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorBusyTask(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsAuthorBusyTask(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorChatRoom(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsAuthorChatRoom(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorDailySchedule(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsAuthorDailySchedule(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /author/task-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsAuthorTask(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsAuthorTask(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsBlogAsset(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsBlogAsset(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /chat_room/{id}/message-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessage(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsChatMessage(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /chat_room/{id}/message/{chat_message_id}-OPTIONS
     * @param {string} id
     * @param {string} chatMessageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessageId(
      id: string,
      chatMessageId: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .optionsChatMessageId(id, chatMessageId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /chat_room/{chat_room_id}/message-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessageRead(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsChatMessageRead(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /author/chat_message/unread/recently-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatMessageUnread(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsChatMessageUnread(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatRoom(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsChatRoom(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /chat_room/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsChatRoomId(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsChatRoomId(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /admin/current-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsCurrentAdmin(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsCurrentAdmin(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /docuement_folder-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsDocumentFolder(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsDocumentFolder(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /document_folder/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsDocumentFolderId(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsDocumentFolderId(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /meeting_place-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsMeetingPlace(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsMeetingPlace(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /meeting_record-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsMeetingRecord(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsMeetingRecord(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * preflight
     * @summary /meeting_record/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsMeetingRecordId(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsMeetingRecordId(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /user/{id}/notify_validation-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsNotifyValidation(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsNotifyValidation(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsPriority(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsPriority(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsProgress(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsProgress(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /author/meeting_record/recently-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsRecentAuthorMeetingRecord(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsRecentAuthorMeetingRecord(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsRoot(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsRoot(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /schedule-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsSchedule(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsSchedule(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /document_folder/{id}-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsScheduleId(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsScheduleId(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /task-OPTIONS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsTask(options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsTask(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /user/{id}/schedule-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsUserActivity(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsUserActivity(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /user/{id}/schedule-OPTIONS
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optionsUserSchedule(id: string, options?: any): AxiosPromise<object> {
      return localVarFp
        .optionsUserSchedule(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /blog_asset-POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postBlogAsset(options?: any): AxiosPromise<object> {
      return localVarFp
        .postBlogAsset(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * post chat message
     * @summary /chat_room/{id}/message-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ChatMessageForm} [chatMessageForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChatMessage(
      id: string,
      authorization?: string,
      origin?: string,
      chatMessageForm?: ChatMessageForm,
      options?: any
    ): AxiosPromise<ChatMessage> {
      return localVarFp
        .postChatMessage(id, authorization, origin, chatMessageForm, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * post chat read
     * @summary /chat_room/{id}/read-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChatRead(
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options?: any
    ): AxiosPromise<ChatRoom> {
      return localVarFp
        .postChatRead(id, authorization, origin, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * return params
     * @summary /chat_room-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ChatRoomForm} [chatRoomForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChatRoom(
      authorization?: string,
      origin?: string,
      chatRoomForm?: ChatRoomForm,
      options?: any
    ): AxiosPromise<ChatRoom> {
      return localVarFp
        .postChatRoom(authorization, origin, chatRoomForm, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * post document folder
     * @summary /docuement_folder-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {DocumentFolderForm} [documentFolderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDocumentFolder(
      authorization?: string,
      origin?: string,
      documentFolderForm?: DocumentFolderForm,
      options?: any
    ): AxiosPromise<DocumentFolder> {
      return localVarFp
        .postDocumentFolder(authorization, origin, documentFolderForm, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * post meeting record
     * @summary /meeting_record-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {MeetingRecordForm} [meetingRecordForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMeetingRecord(
      authorization?: string,
      origin?: string,
      meetingRecordForm?: MeetingRecordForm,
      options?: any
    ): AxiosPromise<MeetingRecord> {
      return localVarFp
        .postMeetingRecord(authorization, origin, meetingRecordForm, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary /meeting_record/{id}/bookmark-POST
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMeetingRecordBookmark(
      id: string,
      authorization?: string,
      origin?: string,
      body?: object,
      options?: any
    ): AxiosPromise<MeetingRecord> {
      return localVarFp
        .postMeetingRecordBookmark(id, authorization, origin, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * post schedule
     * @summary /schedule-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {ScheduleForm} [scheduleForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSchedule(
      authorization?: string,
      origin?: string,
      scheduleForm?: ScheduleForm,
      options?: any
    ): AxiosPromise<Schedule> {
      return localVarFp
        .postSchedule(authorization, origin, scheduleForm, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * post task
     * @summary /task-POST
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {TaskForm} [taskForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTask(
      authorization?: string,
      origin?: string,
      taskForm?: TaskForm,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .postTask(authorization, origin, taskForm, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * update chat message
     * @summary /chat_room/{id}/message/{chat_message_id}-PUT
     * @param {string} chatMessageId
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {ChatMessageForm} [chatMessageForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putChatMessageId(
      chatMessageId: string,
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      chatMessageForm?: ChatMessageForm,
      options?: any
    ): AxiosPromise<ChatMessage> {
      return localVarFp
        .putChatMessageId(
          chatMessageId,
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          chatMessageForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * update chat room data
     * @summary /chat_room/{id}-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {ChatRoomForm} [chatRoomForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putChatRoomId(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      chatRoomForm?: ChatRoomForm,
      options?: any
    ): AxiosPromise<ChatRoom> {
      return localVarFp
        .putChatRoomId(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          chatRoomForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * update document folder
     * @summary /document_folder/{id}-PUT
     * @param {string} id
     * @param {string} [origin]
     * @param {string} [authorization]
     * @param {string} [xHTTPMethodOverride]
     * @param {DocumentFolderForm} [documentFolderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDocumentFolderId(
      id: string,
      origin?: string,
      authorization?: string,
      xHTTPMethodOverride?: string,
      documentFolderForm?: DocumentFolderForm,
      options?: any
    ): AxiosPromise<DocumentFolder> {
      return localVarFp
        .putDocumentFolderId(
          id,
          origin,
          authorization,
          xHTTPMethodOverride,
          documentFolderForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * bookmark meeting record
     * @summary /meeting_record/{id}/bookmark-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMeetingRecordBookmark(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      body?: object,
      options?: any
    ): AxiosPromise<MeetingRecord> {
      return localVarFp
        .putMeetingRecordBookmark(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          body,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * update meeting record
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {MeetingRecordForm} [meetingRecordForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMeetingRecordId(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      meetingRecordForm?: MeetingRecordForm,
      options?: any
    ): AxiosPromise<MeetingRecord> {
      return localVarFp
        .putMeetingRecordId(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          meetingRecordForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * プロフィールの更新
     * @summary /user/{id}/profile-PUT
     * @param {string} id
     * @param {string} familyName
     * @param {string} givenName
     * @param {string} familyNameKana
     * @param {string} givenNameKana
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {boolean} [deleteFlag]
     * @param {any} [file]
     * @param {boolean} [changePassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putProfile(
      id: string,
      familyName: string,
      givenName: string,
      familyNameKana: string,
      givenNameKana: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      deleteFlag?: boolean,
      file?: any,
      changePassword?: boolean,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .putProfile(
          id,
          familyName,
          givenName,
          familyNameKana,
          givenNameKana,
          authorization,
          origin,
          xHTTPMethodOverride,
          deleteFlag,
          file,
          changePassword,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * update schedule
     * @summary /schedule/{id}-PUT
     * @param {string} id
     * @param {string} [origin]
     * @param {string} [authorization]
     * @param {string} [xHTTPMethodOverride]
     * @param {ScheduleForm} [scheduleForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putScheduleId(
      id: string,
      origin?: string,
      authorization?: string,
      xHTTPMethodOverride?: string,
      scheduleForm?: ScheduleForm,
      options?: any
    ): AxiosPromise<Schedule> {
      return localVarFp
        .putScheduleId(
          id,
          origin,
          authorization,
          xHTTPMethodOverride,
          scheduleForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * update task
     * @summary /task/{id}-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {TaskForm} [taskForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTaskId(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      taskForm?: TaskForm,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .putTaskId(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          taskForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * update activity read
     * @summary /user/{id}/activity/read-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserActivityRead(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      body?: object,
      options?: any
    ): AxiosPromise<Activity> {
      return localVarFp
        .putUserActivityRead(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          body,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * update user notify validation
     * @summary /user/{id}/notify_validation-GET
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserNotifyValidation(
      id: string,
      authorization?: string,
      origin?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .putUserNotifyValidation(id, authorization, origin, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * customize user settings
     * @summary /user/{id}/setting-PUT
     * @param {string} id
     * @param {string} [authorization]
     * @param {string} [origin]
     * @param {string} [xHTTPMethodOverride]
     * @param {SettingForm} [settingForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting(
      id: string,
      authorization?: string,
      origin?: string,
      xHTTPMethodOverride?: string,
      settingForm?: SettingForm,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .putUserSetting(
          id,
          authorization,
          origin,
          xHTTPMethodOverride,
          settingForm,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * delete task
   * @summary /author/task-DELETE
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [page]
   * @param {string} [status]
   * @param {string} [sortKey]
   * @param {string} [orderBy]
   * @param {TaskDeleteForm} [taskDeleteForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteAuthorTask(
    authorization?: string,
    origin?: string,
    page?: string,
    status?: string,
    sortKey?: string,
    orderBy?: string,
    taskDeleteForm?: TaskDeleteForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .deleteAuthorTask(
        authorization,
        origin,
        page,
        status,
        sortKey,
        orderBy,
        taskDeleteForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * delete chat message
   * @summary /chat_room/{id}/message/{chat_message_id}-DELETE
   * @param {string} id
   * @param {string} chatMessageId
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteChatMessageId(
    id: string,
    chatMessageId: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .deleteChatMessageId(id, chatMessageId, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * delete chat room
   * @summary /chat_room/{id}-DELETE
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteChatRoomId(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .deleteChatRoomId(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * delete meeting record
   * @summary /meeting_record/{id}-DELETE
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [keyword]
   * @param {string} [sortKey]
   * @param {string} [meetingDate]
   * @param {string} [count]
   * @param {string} [orderBy]
   * @param {string} [onlyBookmark]
   * @param {string} [page]
   * @param {string} [onlyMe]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteMeetingRecordId(
    id: string,
    authorization?: string,
    origin?: string,
    keyword?: string,
    sortKey?: string,
    meetingDate?: string,
    count?: string,
    orderBy?: string,
    onlyBookmark?: string,
    page?: string,
    onlyMe?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .deleteMeetingRecordId(
        id,
        authorization,
        origin,
        keyword,
        sortKey,
        meetingDate,
        count,
        orderBy,
        onlyBookmark,
        page,
        onlyMe,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * delete schedule
   * @summary /schedule/{id}-DELETE
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteScheduleId(
    id: string,
    authorization?: string,
    origin?: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .deleteScheduleId(id, authorization, origin, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * delete meeting record
   * @summary /task/{id}-DELETE
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteTaskId(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .deleteTaskId(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return activity on user
   * @summary /user/{id}/activity-GET
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getActivityByUser(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getActivityByUser(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return chat rooms author has joined
   * @summary /author/chat_room-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAuthorChatRoom(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getAuthorChatRoom(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return author daily schedule
   * @summary /author/schedule/daily-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAuthorDailySchedule(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getAuthorDailySchedule(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return author busy task
   * @summary /author/task/busy-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getBusyTask(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getBusyTask(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return unread message list
   * @summary /author/chat_message/unread/recently-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getChatMessageUnread(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getChatMessageUnread(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return chat room by id
   * @summary /chat_room/{id}-GET
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getChatRoomId(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getChatRoomId(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return current admin
   * @summary /admin/current-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCurrentAdmin(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getCurrentAdmin(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return current auth object
   * @summary /user-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCurrentUser(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getCurrentUser(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return current auth object with chat
   * @summary /user/current/chat_rooms-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCurrentUserWithChat(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getCurrentUserWithChat(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return document folder
   * @summary /docuement_folder-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getDocumentFolder(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getDocumentFolder(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return document folder by id
   * @summary /document_folder/{id}-GET
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getDocumentFolderId(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getDocumentFolderId(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return meeting place list
   * @summary /meeting_place-GET
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMeetingPlace(origin?: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMeetingPlace(origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return meeting record
   * @summary /meeting_record-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [keyword]
   * @param {string} [sortKey]
   * @param {string} [meetingDate]
   * @param {string} [count]
   * @param {string} [orderBy]
   * @param {string} [onlyBookmark]
   * @param {string} [page]
   * @param {string} [onlyMe]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMeetingRecord(
    authorization?: string,
    origin?: string,
    keyword?: string,
    sortKey?: string,
    meetingDate?: string,
    count?: string,
    orderBy?: string,
    onlyBookmark?: string,
    page?: string,
    onlyMe?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getMeetingRecord(
        authorization,
        origin,
        keyword,
        sortKey,
        meetingDate,
        count,
        orderBy,
        onlyBookmark,
        page,
        onlyMe,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return meeting record by id
   * @summary /meeting_record/{id}-GET
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMeetingRecordId(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getMeetingRecordId(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return priority list
   * @summary /priority-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPriority(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getPriority(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return progress list
   * @summary /progress-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getProgress(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getProgress(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return author daily schedule
   * @summary /author/meeting_record/recently-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getRecentAuthorMeetingRecord(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getRecentAuthorMeetingRecord(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getRoot(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getRoot(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return schedule
   * @summary /schedule-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSchedule(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getSchedule(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return schedule by id
   * @summary /schedule/{id}-GET
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getScheduleId(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getScheduleId(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return author task
   * @summary /author/task-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [page]
   * @param {string} [status]
   * @param {string} [orderBy]
   * @param {string} [sortKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getTask(
    authorization?: string,
    origin?: string,
    page?: string,
    status?: string,
    orderBy?: string,
    sortKey?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getTask(authorization, origin, page, status, orderBy, sortKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return task
   * @summary /task-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getTaskPage(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getTaskPage(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 会議の参加者を入力するドロップダウンリスト等に使用
   * @summary /user-GET
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUser(
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getUser(authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return schedule on user
   * @summary /user/{id}/schedule-GET
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserIdSchedule(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getUserIdSchedule(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /user/current-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionCurrentUser(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionCurrentUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /user/current/chat_rooms-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionCurrentUserWithChat(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionCurrentUserWithChat(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /meeting_record/{id}/bookmark-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionMeetingRecordIBookmark(
    id: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .optionMeetingRecordIBookmark(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary user profile
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionProfile(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionProfile(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /task/{id}-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionTaskId(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionTaskId(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /user-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionUser(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /user/{id}/activity-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionUserActivityRead(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionUserActivityRead(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /user/{id}/setting-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionUserSetting(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionUserSetting(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /author/task/busy-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsAuthorBusyTask(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsAuthorBusyTask(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsAuthorChatRoom(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsAuthorChatRoom(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsAuthorDailySchedule(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsAuthorDailySchedule(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /author/task-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsAuthorTask(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsAuthorTask(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsBlogAsset(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsBlogAsset(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /chat_room/{id}/message-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsChatMessage(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsChatMessage(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /chat_room/{id}/message/{chat_message_id}-OPTIONS
   * @param {string} id
   * @param {string} chatMessageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsChatMessageId(
    id: string,
    chatMessageId: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .optionsChatMessageId(id, chatMessageId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /chat_room/{chat_room_id}/message-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsChatMessageRead(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsChatMessageRead(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /author/chat_message/unread/recently-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsChatMessageUnread(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsChatMessageUnread(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsChatRoom(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsChatRoom(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /chat_room/{id}-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsChatRoomId(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsChatRoomId(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /admin/current-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsCurrentAdmin(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsCurrentAdmin(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /docuement_folder-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsDocumentFolder(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsDocumentFolder(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /document_folder/{id}-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsDocumentFolderId(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsDocumentFolderId(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /meeting_place-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsMeetingPlace(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsMeetingPlace(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /meeting_record-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsMeetingRecord(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsMeetingRecord(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * preflight
   * @summary /meeting_record/{id}-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsMeetingRecordId(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsMeetingRecordId(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /user/{id}/notify_validation-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsNotifyValidation(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsNotifyValidation(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsPriority(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsPriority(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsProgress(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsProgress(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /author/meeting_record/recently-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsRecentAuthorMeetingRecord(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsRecentAuthorMeetingRecord(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsRoot(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsRoot(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /schedule-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsSchedule(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsSchedule(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /document_folder/{id}-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsScheduleId(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsScheduleId(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /task-OPTIONS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsTask(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsTask(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /user/{id}/schedule-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsUserActivity(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsUserActivity(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /user/{id}/schedule-OPTIONS
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public optionsUserSchedule(id: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .optionsUserSchedule(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /blog_asset-POST
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postBlogAsset(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .postBlogAsset(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * post chat message
   * @summary /chat_room/{id}/message-POST
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {ChatMessageForm} [chatMessageForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postChatMessage(
    id: string,
    authorization?: string,
    origin?: string,
    chatMessageForm?: ChatMessageForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postChatMessage(id, authorization, origin, chatMessageForm, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * post chat read
   * @summary /chat_room/{id}/read-POST
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postChatRead(
    id: string,
    authorization?: string,
    origin?: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postChatRead(id, authorization, origin, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * return params
   * @summary /chat_room-POST
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {ChatRoomForm} [chatRoomForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postChatRoom(
    authorization?: string,
    origin?: string,
    chatRoomForm?: ChatRoomForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postChatRoom(authorization, origin, chatRoomForm, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * post document folder
   * @summary /docuement_folder-POST
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {DocumentFolderForm} [documentFolderForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postDocumentFolder(
    authorization?: string,
    origin?: string,
    documentFolderForm?: DocumentFolderForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postDocumentFolder(authorization, origin, documentFolderForm, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * post meeting record
   * @summary /meeting_record-POST
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {MeetingRecordForm} [meetingRecordForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postMeetingRecord(
    authorization?: string,
    origin?: string,
    meetingRecordForm?: MeetingRecordForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postMeetingRecord(authorization, origin, meetingRecordForm, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary /meeting_record/{id}/bookmark-POST
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postMeetingRecordBookmark(
    id: string,
    authorization?: string,
    origin?: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postMeetingRecordBookmark(id, authorization, origin, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * post schedule
   * @summary /schedule-POST
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {ScheduleForm} [scheduleForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postSchedule(
    authorization?: string,
    origin?: string,
    scheduleForm?: ScheduleForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postSchedule(authorization, origin, scheduleForm, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * post task
   * @summary /task-POST
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {TaskForm} [taskForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postTask(
    authorization?: string,
    origin?: string,
    taskForm?: TaskForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .postTask(authorization, origin, taskForm, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update chat message
   * @summary /chat_room/{id}/message/{chat_message_id}-PUT
   * @param {string} chatMessageId
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {ChatMessageForm} [chatMessageForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putChatMessageId(
    chatMessageId: string,
    id: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    chatMessageForm?: ChatMessageForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putChatMessageId(
        chatMessageId,
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        chatMessageForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update chat room data
   * @summary /chat_room/{id}-PUT
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {ChatRoomForm} [chatRoomForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putChatRoomId(
    id: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    chatRoomForm?: ChatRoomForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putChatRoomId(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        chatRoomForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update document folder
   * @summary /document_folder/{id}-PUT
   * @param {string} id
   * @param {string} [origin]
   * @param {string} [authorization]
   * @param {string} [xHTTPMethodOverride]
   * @param {DocumentFolderForm} [documentFolderForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putDocumentFolderId(
    id: string,
    origin?: string,
    authorization?: string,
    xHTTPMethodOverride?: string,
    documentFolderForm?: DocumentFolderForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putDocumentFolderId(
        id,
        origin,
        authorization,
        xHTTPMethodOverride,
        documentFolderForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * bookmark meeting record
   * @summary /meeting_record/{id}/bookmark-PUT
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putMeetingRecordBookmark(
    id: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putMeetingRecordBookmark(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        body,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update meeting record
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {MeetingRecordForm} [meetingRecordForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putMeetingRecordId(
    id: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    meetingRecordForm?: MeetingRecordForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putMeetingRecordId(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        meetingRecordForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * プロフィールの更新
   * @summary /user/{id}/profile-PUT
   * @param {string} id
   * @param {string} familyName
   * @param {string} givenName
   * @param {string} familyNameKana
   * @param {string} givenNameKana
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {boolean} [deleteFlag]
   * @param {any} [file]
   * @param {boolean} [changePassword]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putProfile(
    id: string,
    familyName: string,
    givenName: string,
    familyNameKana: string,
    givenNameKana: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    deleteFlag?: boolean,
    file?: any,
    changePassword?: boolean,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putProfile(
        id,
        familyName,
        givenName,
        familyNameKana,
        givenNameKana,
        authorization,
        origin,
        xHTTPMethodOverride,
        deleteFlag,
        file,
        changePassword,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update schedule
   * @summary /schedule/{id}-PUT
   * @param {string} id
   * @param {string} [origin]
   * @param {string} [authorization]
   * @param {string} [xHTTPMethodOverride]
   * @param {ScheduleForm} [scheduleForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putScheduleId(
    id: string,
    origin?: string,
    authorization?: string,
    xHTTPMethodOverride?: string,
    scheduleForm?: ScheduleForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putScheduleId(
        id,
        origin,
        authorization,
        xHTTPMethodOverride,
        scheduleForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update task
   * @summary /task/{id}-PUT
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {TaskForm} [taskForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putTaskId(
    id: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    taskForm?: TaskForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putTaskId(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        taskForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update activity read
   * @summary /user/{id}/activity/read-PUT
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putUserActivityRead(
    id: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putUserActivityRead(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        body,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update user notify validation
   * @summary /user/{id}/notify_validation-GET
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putUserNotifyValidation(
    id: string,
    authorization?: string,
    origin?: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putUserNotifyValidation(id, authorization, origin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * customize user settings
   * @summary /user/{id}/setting-PUT
   * @param {string} id
   * @param {string} [authorization]
   * @param {string} [origin]
   * @param {string} [xHTTPMethodOverride]
   * @param {SettingForm} [settingForm]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putUserSetting(
    id: string,
    authorization?: string,
    origin?: string,
    xHTTPMethodOverride?: string,
    settingForm?: SettingForm,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .putUserSetting(
        id,
        authorization,
        origin,
        xHTTPMethodOverride,
        settingForm,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
